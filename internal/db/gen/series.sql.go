// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: series.sql

package db

import (
	"context"
	"database/sql"
)

const addPostToSeries = `-- name: AddPostToSeries :exec
INSERT INTO post_series (post_id, series_id, order_in_series)
VALUES (?, ?, ?)
ON CONFLICT(post_id, series_id) DO UPDATE SET order_in_series = ?
`

type AddPostToSeriesParams struct {
	PostID        string        `db:"post_id" json:"post_id"`
	SeriesID      string        `db:"series_id" json:"series_id"`
	OrderInSeries sql.NullInt64 `db:"order_in_series" json:"order_in_series"`
}

func (q *Queries) AddPostToSeries(ctx context.Context, arg AddPostToSeriesParams) error {
	_, err := q.db.ExecContext(ctx, addPostToSeries, arg.PostID, arg.SeriesID, arg.OrderInSeries)
	return err
}

const createSeries = `-- name: CreateSeries :one
INSERT INTO series (id, name, slug, description, created_at)
VALUES (?, ?, ?, ?, ?)
RETURNING id, name, slug, description, created_at
`

type CreateSeriesParams struct {
	ID          string         `db:"id" json:"id"`
	Name        string         `db:"name" json:"name"`
	Slug        string         `db:"slug" json:"slug"`
	Description sql.NullString `db:"description" json:"description"`
	CreatedAt   sql.NullTime   `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateSeries(ctx context.Context, arg CreateSeriesParams) (Series, error) {
	row := q.db.QueryRowContext(ctx, createSeries,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.CreatedAt,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSeries = `-- name: DeleteSeries :exec
DELETE FROM series WHERE id = ?
`

func (q *Queries) DeleteSeries(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSeries, id)
	return err
}

const getPostSeries = `-- name: GetPostSeries :many
SELECT s.id, s.name, s.slug, s.description, s.created_at FROM series s
JOIN post_series ps ON s.id = ps.series_id
WHERE ps.post_id = ?
ORDER BY ps.order_in_series ASC
`

func (q *Queries) GetPostSeries(ctx context.Context, postID string) ([]Series, error) {
	rows, err := q.db.QueryContext(ctx, getPostSeries, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Series
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeries = `-- name: GetSeries :one
SELECT id, name, slug, description, created_at FROM series
WHERE id = ? OR slug = ?
LIMIT 1
`

type GetSeriesParams struct {
	ID   string `db:"id" json:"id"`
	Slug string `db:"slug" json:"slug"`
}

func (q *Queries) GetSeries(ctx context.Context, arg GetSeriesParams) (Series, error) {
	row := q.db.QueryRowContext(ctx, getSeries, arg.ID, arg.Slug)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getSeriesPosts = `-- name: GetSeriesPosts :many
SELECT p.id, p.type_id, p.title, p.slug, p.content, p.excerpt, p.status, p.is_featured, p.tags, p.metadata, p.created_at, p.updated_at, p.published_at FROM posts p
JOIN post_series ps ON p.id = ps.post_id
WHERE ps.series_id = ?
ORDER BY ps.order_in_series ASC
`

func (q *Queries) GetSeriesPosts(ctx context.Context, seriesID string) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getSeriesPosts, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.Excerpt,
			&i.Status,
			&i.IsFeatured,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initSeriesTables = `-- name: InitSeriesTables :exec
CREATE TABLE IF NOT EXISTS series (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  description TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
)
`

// Ensure tables exist
func (q *Queries) InitSeriesTables(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, initSeriesTables)
	return err
}

const listSeries = `-- name: ListSeries :many
SELECT id, name, slug, description, created_at FROM series
ORDER BY created_at DESC
LIMIT ?2 OFFSET ?1
`

type ListSeriesParams struct {
	Offset int64 `db:"offset" json:"offset"`
	Limit  int64 `db:"limit" json:"limit"`
}

func (q *Queries) ListSeries(ctx context.Context, arg ListSeriesParams) ([]Series, error) {
	rows, err := q.db.QueryContext(ctx, listSeries, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Series
	for rows.Next() {
		var i Series
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePostFromSeries = `-- name: RemovePostFromSeries :exec
DELETE FROM post_series WHERE post_id = ? AND series_id = ?
`

type RemovePostFromSeriesParams struct {
	PostID   string `db:"post_id" json:"post_id"`
	SeriesID string `db:"series_id" json:"series_id"`
}

func (q *Queries) RemovePostFromSeries(ctx context.Context, arg RemovePostFromSeriesParams) error {
	_, err := q.db.ExecContext(ctx, removePostFromSeries, arg.PostID, arg.SeriesID)
	return err
}

const updateSeries = `-- name: UpdateSeries :one
UPDATE series SET
  name = ?,
  slug = ?,
  description = ?
WHERE id = ?
RETURNING id, name, slug, description, created_at
`

type UpdateSeriesParams struct {
	Name        string         `db:"name" json:"name"`
	Slug        string         `db:"slug" json:"slug"`
	Description sql.NullString `db:"description" json:"description"`
	ID          string         `db:"id" json:"id"`
}

func (q *Queries) UpdateSeries(ctx context.Context, arg UpdateSeriesParams) (Series, error) {
	row := q.db.QueryRowContext(ctx, updateSeries,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.ID,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}
