// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: posts.sql

package db

import (
	"context"
	"database/sql"
)

const countPosts = `-- name: CountPosts :one
SELECT COUNT(*) as count FROM posts
WHERE 1=1
  AND (?1 IS NULL OR status = ?1)
  AND (?2 IS NULL OR type_id = ?2)
`

type CountPostsParams struct {
	Status interface{} `db:"status" json:"status"`
	TypeID interface{} `db:"type_id" json:"type_id"`
}

func (q *Queries) CountPosts(ctx context.Context, arg CountPostsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPosts, arg.Status, arg.TypeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (id, type_id, title, slug, content, excerpt, status, is_featured, tags, metadata, created_at, updated_at, published_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, type_id, title, slug, content, excerpt, status, is_featured, tags, metadata, created_at, updated_at, published_at
`

type CreatePostParams struct {
	ID          string         `db:"id" json:"id"`
	TypeID      string         `db:"type_id" json:"type_id"`
	Title       string         `db:"title" json:"title"`
	Slug        string         `db:"slug" json:"slug"`
	Content     string         `db:"content" json:"content"`
	Excerpt     sql.NullString `db:"excerpt" json:"excerpt"`
	Status      sql.NullString `db:"status" json:"status"`
	IsFeatured  sql.NullBool   `db:"is_featured" json:"is_featured"`
	Tags        sql.NullString `db:"tags" json:"tags"`
	Metadata    sql.NullString `db:"metadata" json:"metadata"`
	CreatedAt   sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt   sql.NullTime   `db:"updated_at" json:"updated_at"`
	PublishedAt sql.NullTime   `db:"published_at" json:"published_at"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.TypeID,
		arg.Title,
		arg.Slug,
		arg.Content,
		arg.Excerpt,
		arg.Status,
		arg.IsFeatured,
		arg.Tags,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.PublishedAt,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Excerpt,
		&i.Status,
		&i.IsFeatured,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}

const createRevision = `-- name: CreateRevision :exec
INSERT INTO revisions (id, post_id, content, created_at)
VALUES (?, ?, ?, ?)
`

type CreateRevisionParams struct {
	ID        string       `db:"id" json:"id"`
	PostID    string       `db:"post_id" json:"post_id"`
	Content   string       `db:"content" json:"content"`
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateRevision(ctx context.Context, arg CreateRevisionParams) error {
	_, err := q.db.ExecContext(ctx, createRevision,
		arg.ID,
		arg.PostID,
		arg.Content,
		arg.CreatedAt,
	)
	return err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts WHERE id = ?
`

func (q *Queries) DeletePost(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deletePost, id)
	return err
}

const getPost = `-- name: GetPost :one
SELECT id, type_id, title, slug, content, excerpt, status, is_featured, tags, metadata, created_at, updated_at, published_at FROM posts
WHERE id = ? OR slug = ?
LIMIT 1
`

type GetPostParams struct {
	ID   string `db:"id" json:"id"`
	Slug string `db:"slug" json:"slug"`
}

func (q *Queries) GetPost(ctx context.Context, arg GetPostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, getPost, arg.ID, arg.Slug)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Excerpt,
		&i.Status,
		&i.IsFeatured,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}

const getPostTypes = `-- name: GetPostTypes :many
SELECT id, name, slug, description FROM post_types ORDER BY name
`

func (q *Queries) GetPostTypes(ctx context.Context) ([]PostType, error) {
	rows, err := q.db.QueryContext(ctx, getPostTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostType
	for rows.Next() {
		var i PostType
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevisions = `-- name: GetRevisions :many
SELECT id, post_id, content, created_at FROM revisions
WHERE post_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetRevisions(ctx context.Context, postID string) ([]Revision, error) {
	rows, err := q.db.QueryContext(ctx, getRevisions, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Revision
	for rows.Next() {
		var i Revision
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initPostTables = `-- name: InitPostTables :exec
CREATE TABLE IF NOT EXISTS post_types (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  description TEXT
)
`

// Ensure tables exist
func (q *Queries) InitPostTables(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, initPostTables)
	return err
}

const listPosts = `-- name: ListPosts :many
SELECT id, type_id, title, slug, content, excerpt, status, is_featured, tags, metadata, created_at, updated_at, published_at FROM posts
WHERE 1=1
  AND (?1 IS NULL OR status = ?1)
  AND (?2 IS NULL OR type_id = ?2)
ORDER BY created_at DESC, published_at DESC
LIMIT ?4 OFFSET ?3
`

type ListPostsParams struct {
	Status interface{} `db:"status" json:"status"`
	TypeID interface{} `db:"type_id" json:"type_id"`
	Offset int64       `db:"offset" json:"offset"`
	Limit  int64       `db:"limit" json:"limit"`
}

func (q *Queries) ListPosts(ctx context.Context, arg ListPostsParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, listPosts,
		arg.Status,
		arg.TypeID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.TypeID,
			&i.Title,
			&i.Slug,
			&i.Content,
			&i.Excerpt,
			&i.Status,
			&i.IsFeatured,
			&i.Tags,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts SET
  title = COALESCE(?3, title),
  slug = COALESCE(?4, slug),
  content = COALESCE(?5, content),
  excerpt = COALESCE(?6, excerpt),
  status = COALESCE(?7, status),
  is_featured = COALESCE(?8, is_featured),
  tags = COALESCE(?9, tags),
  metadata = COALESCE(?10, metadata),
  published_at = COALESCE(?11, published_at),
  updated_at = ?
WHERE id = ?
RETURNING id, type_id, title, slug, content, excerpt, status, is_featured, tags, metadata, created_at, updated_at, published_at
`

type UpdatePostParams struct {
	Title       sql.NullString `db:"title" json:"title"`
	Slug        sql.NullString `db:"slug" json:"slug"`
	Content     sql.NullString `db:"content" json:"content"`
	Excerpt     sql.NullString `db:"excerpt" json:"excerpt"`
	Status      sql.NullString `db:"status" json:"status"`
	IsFeatured  sql.NullBool   `db:"is_featured" json:"is_featured"`
	Tags        sql.NullString `db:"tags" json:"tags"`
	Metadata    sql.NullString `db:"metadata" json:"metadata"`
	PublishedAt sql.NullTime   `db:"published_at" json:"published_at"`
	UpdatedAt   sql.NullTime   `db:"updated_at" json:"updated_at"`
	ID          string         `db:"id" json:"id"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRowContext(ctx, updatePost,
		arg.Title,
		arg.Slug,
		arg.Content,
		arg.Excerpt,
		arg.Status,
		arg.IsFeatured,
		arg.Tags,
		arg.Metadata,
		arg.PublishedAt,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.TypeID,
		&i.Title,
		&i.Slug,
		&i.Content,
		&i.Excerpt,
		&i.Status,
		&i.IsFeatured,
		&i.Tags,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
	)
	return i, err
}
