<!doctype html>
<html
  lang="en-us"
  dir="ltr"
  class="scroll-smooth"
  data-default-appearance="light"
  data-auto-appearance="true"><head>
  <meta charset="utf-8">
  
    <meta http-equiv="content-language" content="en-us">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color">

  
  
    <title>Golang: Go Routines and WaitGroups &middot; Notes</title>
    <meta name="title" content="Golang: Go Routines and WaitGroups &middot; Notes">
  

  
  
    <meta name="description" content="A collection of technical notes and posts">
  
  
    <meta name="keywords" content="go,">
  
  
  
  <link rel="canonical" href="/posts/golang-go-routines/">
  

  
  
    <meta name="author" content="Meet Gor">
  
  

  
  <meta property="og:url" content="/posts/golang-go-routines/">
  <meta property="og:site_name" content="Notes">
  <meta property="og:title" content="Golang: Go Routines and WaitGroups">
  <meta property="og:description" content="Introduction # One of the key features that set Go apart from many other languages is its native support for Goroutines - lightweight concurrent functions that can run concurrently and efficiently manage concurrency tasks. Goroutines are an essential aspect of Go‚Äôs concurrency model, enabling developers to build highly concurrent and performant applications effortlessly.
In this blog post, we will dive into the world of Goroutines and explore how they work, why they are essential for concurrent programming in Go, and how they can greatly improve the responsiveness and efficiency of your applications. This post will cover go routines and a primer on wait groups, in the next article we will be looking deeply into channels where all these three things can be demonstrated and understood in a better and more useful way.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-29T15:15:00+00:00">
    <meta property="article:modified_time" content="2026-01-04T15:49:51+05:30">
    <meta property="article:tag" content="Go">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Golang: Go Routines and WaitGroups">
  <meta name="twitter:description" content="Introduction # One of the key features that set Go apart from many other languages is its native support for Goroutines - lightweight concurrent functions that can run concurrently and efficiently manage concurrency tasks. Goroutines are an essential aspect of Go‚Äôs concurrency model, enabling developers to build highly concurrent and performant applications effortlessly.
In this blog post, we will dive into the world of Goroutines and explore how they work, why they are essential for concurrent programming in Go, and how they can greatly improve the responsiveness and efficiency of your applications. This post will cover go routines and a primer on wait groups, in the next article we will be looking deeply into channels where all these three things can be demonstrated and understood in a better and more useful way.">

  
  
  
  
    
      
    
  
    
      
    
  
    
      
    
  
  
    
  

  
  
  
  
  
  

  

  
  
  
  
  
  
  
  
    
  
  
  <link
    type="text/css"
    rel="stylesheet"
    href="/css/main.bundle.min.c61736128cfa071f52268b924e8b8c8dff7f9e962caae1e812053e9e023a4e1c1c95239d517406a4002933de9dd5ad84667956aa9d4230a25024e7e502058ca1.css"
    integrity="sha512-xhc2Eoz6Bx9SJouSTouMjf9/npYsquHoEgU&#43;ngI6ThwclSOdUXQGpAApM96d1a2EZnlWqp1CMKJQJOflAgWMoQ==">

  
  
  <script
    type="text/javascript"
    src="/js/appearance.min.6f41174b3a05b680820fe08cadbfa5fb7a7ca347b76a0955cdc68b9d8aca1ce24f0547e138cea33bcc7904d551a90afcb1cc7f2d9fe8557075d501419046c08c.js"
    integrity="sha512-b0EXSzoFtoCCD&#43;CMrb&#43;l&#43;3p8o0e3aglVzcaLnYrKHOJPBUfhOM6jO8x5BNVRqQr8scx/LZ/oVXB11QFBkEbAjA=="></script>
  
  
  
  
  
  
    
    <script src="/lib/zoom/zoom.min.umd.a527109b68c082a70f3697716dd72a9d5aa8b545cf800cecbbc7399f2ca6f6e0ce3e431f2062b48bbfa47c9ea42822714060bef309be073f49b9c0e30d318d7b.js" integrity="sha512-pScQm2jAgqcPNpdxbdcqnVqotUXPgAzsu8c5nyym9uDOPkMfIGK0i7&#43;kfJ6kKCJxQGC&#43;8wm&#43;Bz9JucDjDTGNew=="></script>
  

  
  
  
    
  
  
    
  
  
  
  
  
  
  
    
    <script
      defer
      type="text/javascript"
      id="script-bundle"
      src="/js/main.bundle.min.67624a357c928d29b9fe19ba01a1e32c05ad1329ca2a712bf10446df0c6872903d0c14b21f76896b57a5a0710940805416cee38851d9067db6555881188e35a5.js"
      integrity="sha512-Z2JKNXySjSm5/hm6AaHjLAWtEynKKnEr8QRG3wxocpA9DBSyH3aJa1eloHEJQIBUFs7jiFHZBn22VViBGI41pQ=="
      data-copy="Copy"
      data-copied="Copied"></script>
  

  
  

<script src="/lib/jquery/jquery.slim.min.b0dca576e87d7eaa5850ae4e61759c065786cdb6489d68fcc82240539eebd5da522bdb4fda085ffd245808c8fe2acb2516408eb774ef26b5f6015fc6737c0ea8.js" integrity="sha512-sNylduh9fqpYUK5OYXWcBleGzbZInWj8yCJAU57r1dpSK9tP2ghf/SRYCMj&#43;KsslFkCOt3TvJrX2AV/Gc3wOqA=="></script>


























  

  

  

  

  








  
  
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
  

  
  <script type="application/ld+json">
  [{
    "@context": "https://schema.org",
    "@type": "Article",
    "articleSection": "Posts",
    "name": "Golang: Go Routines and WaitGroups",
    "headline": "Golang: Go Routines and WaitGroups",
    
    "inLanguage": "en-us",
    "url" : "/posts/golang-go-routines/",
    "author" : {
      "@type": "Person",
      "name": "Meet Gor"
    },
    "copyrightYear": "2023",
    "dateCreated": "2023-07-29T15:15:00\u002b00:00",
    "datePublished": "2023-07-29T15:15:00\u002b00:00",
    
    "dateModified": "2026-01-04T15:49:51\u002b05:30",
    
    "keywords": ["go"],
    
    "mainEntityOfPage": "true",
    "wordCount": "4946"
  }]
  </script>



  
  
    




  

  
  

  
  

  
  

  
  
</head>


















  
  <body class="flex flex-col h-screen m-auto leading-7 max-w-7xl px-6 sm:px-14 md:px-24 lg:px-32 text-lg bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral bf-scrollbar">
    <div id="the-top" class="absolute flex self-center">
      <a
        class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600"
        href="#main-content">
        <span class="font-bold text-primary-600 pe-2 dark:text-primary-400">&darr;</span>
        Skip to main content
      </a>
    </div>
    
    
      <div class="main-menu flex items-center w-full gap-2 p-1 pl-0">
  
  
    <a href="/" class="text-base font-medium truncate min-w-0 shrink">
      Notes
    </a>
  
  <div class="flex items-center ms-auto">
    <div class="hidden md:flex">
      <nav class="flex items-center gap-x-5 h-12">
  
    
      
  
    <a
      href="/"
      
      class="flex items-center bf-icon-color-hover"
      aria-label="Home"
      title="">
      
      
        <span class="text-base font-medium break-normal">
          Home
        </span>
      
    </a>
  

    
      
  
    <a
      href="/posts/"
      
      class="flex items-center bf-icon-color-hover"
      aria-label="Posts"
      title="">
      
      
        <span class="text-base font-medium break-normal">
          Posts
        </span>
      
    </a>
  

    
      
  
    <a
      href="/tags/"
      
      class="flex items-center bf-icon-color-hover"
      aria-label="Tags"
      title="">
      
      
        <span class="text-base font-medium break-normal">
          Tags
        </span>
      
    </a>
  

    
  

  

  

  
    <button
      id="search-button"
      aria-label="Search"
      class="text-base bf-icon-color-hover"
      title="Search (/)">
      <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
    </button>
  

  
    <div class="flex items-center">
      <button
        id="appearance-switcher"
        aria-label="Dark mode switcher"
        type="button"
        class="text-base bf-icon-color-hover">
        <div class="flex items-center justify-center dark:hidden">
          <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>
</span>
        </div>
        <div class="items-center justify-center hidden dark:flex">
          <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>
</span>
        </div>
      </button>
    </div>
  
</nav>



    </div>
    <div class="flex md:hidden">
      <div class="flex items-center h-14 gap-4">
  
    <button
      id="search-button-mobile"
      aria-label="Search"
      class="flex items-center justify-center bf-icon-color-hover"
      title="Search (/)">
      <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
    </button>
  

  
    <button
      id="appearance-switcher-mobile"
      type="button"
      aria-label="Dark mode switcher"
      class="flex items-center justify-center text-neutral-900 hover:text-primary-600 dark:text-neutral-200 dark:hover:text-primary-400">
      <div class="dark:hidden">
        <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M32 256c0-123.8 100.3-224 223.8-224c11.36 0 29.7 1.668 40.9 3.746c9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3c9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480C132.1 480 32 379.6 32 256z"/></svg>
</span>
      </div>
      <div class="hidden dark:block">
        <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 159.1c-53.02 0-95.1 42.98-95.1 95.1S202.1 351.1 256 351.1s95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347L446.1 255.1l63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7l-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89L164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6L12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256l-63.15 91.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7l19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109l109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69 0-127.1-57.31-127.1-127.1c0-70.69 57.31-127.1 127.1-127.1s127.1 57.3 127.1 127.1C383.1 326.7 326.7 383.1 256 383.1z"/></svg>
</span>
      </div>
    </button>
  

  
    <input type="checkbox" id="mobile-menu-toggle" autocomplete="off" class="hidden peer">
    <label for="mobile-menu-toggle" class="flex items-center justify-center cursor-pointer bf-icon-color-hover">
      <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M0 96C0 78.33 14.33 64 32 64H416C433.7 64 448 78.33 448 96C448 113.7 433.7 128 416 128H32C14.33 128 0 113.7 0 96zM0 256C0 238.3 14.33 224 32 224H416C433.7 224 448 238.3 448 256C448 273.7 433.7 288 416 288H32C14.33 288 0 273.7 0 256zM416 448H32C14.33 448 0 433.7 0 416C0 398.3 14.33 384 32 384H416C433.7 384 448 398.3 448 416C448 433.7 433.7 448 416 448z"/></svg>
</span>
    </label>

    <div
      role="dialog"
      aria-modal="true"
      style="scrollbar-gutter: stable;"
      class="fixed inset-0 z-50 invisible overflow-y-auto px-6 py-20 opacity-0 transition-[opacity,visibility] duration-300 peer-checked:visible peer-checked:opacity-100 bg-neutral-50/97 dark:bg-neutral-900/99
      bf-scrollbar">
      <label
        for="mobile-menu-toggle"
        class="fixed end-8 top-5 flex items-center justify-center z-50 h-12 w-12 cursor-pointer select-none rounded-full bf-icon-color-hover border bf-border-color bf-border-color-hover bg-neutral-50 dark:bg-neutral-900">
        <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>
</span>
      </label>
      <nav class="mx-auto max-w-md space-y-6">
        
  
    
    <div class="px-2">
      <a
        href="/"
        aria-label="Home"
        
        class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200">
        
        <span title="" class="text-2xl font-bold tracking-tight">
          Home
        </span>
        
      </a>

      
    </div>
  
    
    <div class="px-2">
      <a
        href="/posts/"
        aria-label="Posts"
        
        class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200">
        
        <span title="" class="text-2xl font-bold tracking-tight">
          Posts
        </span>
        
      </a>

      
    </div>
  
    
    <div class="px-2">
      <a
        href="/tags/"
        aria-label="Tags"
        
        class="flex items-center gap-4 group bf-icon-color-hover text-neutral-700 dark:text-neutral-200">
        
        <span title="" class="text-2xl font-bold tracking-tight">
          Tags
        </span>
        
      </a>

      
    </div>
  

        
  

        
  

      </nav>
    </div>
  
</div>







    </div>
  </div>
</div>





    
    <div class="relative flex flex-col grow">
      <main id="main-content" class="grow">
        
  
  <article>
    
    

    
    <header id="single_header" class="mt-5 max-w-prose">
      
      <h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">
        Golang: Go Routines and WaitGroups
      </h1>
      <div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden">
        





  
  



  

  
  
  
    
  

  

  
    
  

  

  
    
  

  
    
  

  

  

  

  

  


  <div class="flex flex-row flex-wrap items-center">
    
    
      <time datetime="2023-07-29T15:15:00&#43;00:00">July 29, 2023</time><span class="px-2 text-primary-500">&middot;</span><span>4946 words</span><span class="px-2 text-primary-500">&middot;</span><span title="Reading time">24 mins</span>
    

    
    
  </div>

  

  
  

  
  



      </div>
      
        
  
  
  
  
  
  

  

  
    
    
<div class="flex author">
  
  <div class="place-self-center">
    
      <div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">
        Author
      </div>
      <div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">
        Meet Gor
      </div>
    
    
    <div class="text-2xl sm:text-lg">
</div>
  </div>
</div>

  

  

  
    <div class="mb-5"></div>
  

      
    </header>

    
    <section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row">
      
      
      
      
      


      <div class="min-w-0 min-h-0 max-w-fit">
        
        <div class="article-content max-w-prose mb-20">
          
<h2 class="relative group">Introduction
    <div id="introduction" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#introduction" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>One of the key features that set Go apart from many other languages is its native support for Goroutines - lightweight concurrent functions that can run concurrently and efficiently manage concurrency tasks. Goroutines are an essential aspect of Go&rsquo;s concurrency model, enabling developers to build highly concurrent and performant applications effortlessly.</p>
<p>In this blog post, we will dive into the world of Goroutines and explore how they work, why they are essential for concurrent programming in Go, and how they can greatly improve the responsiveness and efficiency of your applications. This post will cover go routines and a primer on wait groups, in the next article we will be looking deeply into channels where all these three things can be demonstrated and understood in a better and more useful way.</p>

<h2 class="relative group">Concurrency and Parallelism
    <div id="concurrency-and-parallelism" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#concurrency-and-parallelism" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>This two concepts are quite crucial before diving into the fundamentals of concurreny.</p>
<p><strong>Concurrency</strong> is about dealing with multiple things at once. Concurrent programs can have several processes or threads running simultaneously on a single CPU core by rapidly switching between them (context switching). The threads are interleaved, not necessarily executing at literally the same time. The CPU can switch between these tasks to give the appearance of simultaneous progress.</p>
<p><strong>Parallelism</strong> is about doing multiple things at literally the same time. Parallel programs can execute multiple computations simultaneously on separate CPU cores. The threads actually execute in parallel.</p>

<h2 class="relative group">What is a Go Routine
    <div id="what-is-a-go-routine" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#what-is-a-go-routine" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>A go routine is a simple lightweight thread managed by the Go runtime. In the simplest of terms, a go routine can be defined as:</p>
<blockquote><p>Go routine is a way to perform multiple tasks within a program, allowing different parts of the program to work simultaneously and make the most out of the resources.</p>
</blockquote><p>Also it can be stated as:</p>
<p>A goroutine in Golang is a lightweight, independently executing function that runs concurrently with other goroutines within the same address space. In other words, it is a concurrent unit of execution.</p>
<p>Focussing on the word <strong>same address space</strong> that will be really critical in the later sections of this article.</p>

<h2 class="relative group">Features of Go Routines
    <div id="features-of-go-routines" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#features-of-go-routines" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Go routines form a key part of Go&rsquo;s concurrency model. Here are some of the key features of go routines:</p>
<ul>
<li>
<p><strong>Lightweight Thread</strong>:<br>
A Go routine is often referred to as a lightweight thread.</p>
</li>
<li>
<p><strong>Independent Execution</strong>:<br>
Go routines run independently of each other, enabling concurrent execution.</p>
</li>
<li>
<p><strong>Managed by Go</strong>:<br>
Go routines are managed by the Go runtime, making them easy to use.</p>
</li>
<li>
<p><strong>Low Overhead</strong>:<br>
Go routines have low memory overhead, allowing us to create thousands of them efficiently.</p>
</li>
<li>
<p><strong>Communication</strong>:<br>
Go routines can communicate and synchronize data through channels.</p>
</li>
<li>
<p><strong>Asynchronous</strong>:<br>
Go routines can execute asynchronously, allowing other parts of the program to continue running.</p>
</li>
<li>
<p><strong>Scalability</strong>:<br>
Go routines are the foundation of scalable concurrent programming in Go.</p>
</li>
</ul>
<p>Unlike threads in other languages, goroutines are cheap and you can easily create thousands or even millions of them in a program.</p>

<h2 class="relative group">Example of Go Routines
    <div id="example-of-go-routines" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#example-of-go-routines" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Creating a go routine is not hard, just add the keyword <code>go</code> before the function call and the go runtime will create a new go routine inside the main function or wherever is the context from. Remember, the main function is also a go routine.</p>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">process</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Hello World!&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">process</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">process</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">duration</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">end</span>.<span style="color:#a6e22e">Sub</span>(<span style="color:#a6e22e">start</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">duration</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>scripts/go-routines on ÓÇ† main via üêπ v1.20 
</span></span><span style="display:flex;"><span>$ go run main.go 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Hello World!
</span></span><span style="display:flex;"><span>15.607¬µs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scripts/go-routines on ÓÇ† main via üêπ v1.20 
</span></span><span style="display:flex;"><span>$ go run main.go 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>9.889¬µs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scripts/go-routines on ÓÇ† main via üêπ v1.20 
</span></span><span style="display:flex;"><span>$ go run main.go 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>8.834¬µs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scripts/go-routines on ÓÇ† main via üêπ v1.20 
</span></span><span style="display:flex;"><span>$ go run main.go 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>9.158¬µs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scripts/go-routines on ÓÇ† main via üêπ v1.20 
</span></span><span style="display:flex;"><span>$ go run main.go 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>12.54¬µs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scripts/go-routines on ÓÇ† main via üêπ v1.20 
</span></span><span style="display:flex;"><span>$ go run main.go 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Hello World!
</span></span><span style="display:flex;"><span>Hello World!
</span></span><span style="display:flex;"><span>10.19¬µs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scripts/go-routines on ÓÇ† main via üêπ v1.20 
</span></span><span style="display:flex;"><span>$ go run main.go 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>14.1¬µs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scripts/go-routines on ÓÇ† main via üêπ v1.20 
</span></span><span style="display:flex;"><span>$ </span></span></code></pre></div></div>
<p>Quite unpredictable output right? This is a power of go-routines. It is <strong>asynchronous</strong> so it will not block the main function. The two function calls to <code>process</code>, are executed independently of the main function scope. The program just calls the process function and captures the output, and sequentially reaches the end of the program(main function), At this point the go routines(threads) inside the main function are stopped abruptly.</p>
<p>Let&rsquo;s break it down if it is not clear yet.</p>
<ul>
<li>The main function starts.</li>
<li><code>go process()</code> creates a Go routine and starts its execution.</li>
<li>Meanwhile, another call to <code>go process()</code> creates a separate Go routine and starts its execution as well.</li>
<li>Meanwhile, calculate the time difference between the main function start and end.</li>
<li>Meanwhile main function ends.</li>
</ul>
<p>So, in summary, the main function is only able to capture the output of the <code>duration</code> as it is synchronous and if the process has been executed, it prints the <code>Hello World!</code> message. Hence we have different outputs because the uncontrolled concurrency, lack of coordination, and OS scheduling across the program runs are different.</p>

<h2 class="relative group">Wait Groups
    <div id="wait-groups" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#wait-groups" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>In simple terms, WaitGroup is used to synchronize multiple goroutines and to wait for them to finish executing. This allows the go routines to be completed before the completion of the main function, hence it blocks the main function from leaving/exiting the scope.</p>
<blockquote><p>A WaitGroup is a synchronization primitive that allows a goroutine to wait for a collection of other goroutines to finish executing.</p>
</blockquote><ul>
<li>A WaitGroup is initialized with a counter representing the number of goroutines to wait for.</li>
<li>The Add() method increments the counter by the given value. This is called by each goroutine to indicate it is running.</li>
<li>The main goroutine calls Add() to set the initial count, then launches worker goroutines.</li>
<li>A WaitGroup is typically passed by a pointer to goroutines that need to be waited on.</li>
<li>The Done() method decrements the counter by 1. Goroutines call this when finished.</li>
<li>Each worker calls Done() when finished, decrementing the counter.</li>
<li>The Wait() method blocks until the counter reaches 0, indicating all goroutines have finished.</li>
<li>Main calls Wait() to block until Done() brings counter to 0.</li>
</ul>
<p>This provides a simple way to synchronize multiple goroutines finishing their work with a main thread that needs to wait for them to complete. The counter ensures the main thread knows how many goroutines it is waiting for. Interacting and working with go routines with synchronization using a wait group is quite intuitive and simple to follow. Let&rsquo;s look at a simple example below:</p>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">process</span>(<span style="color:#a6e22e">pid</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Started process %d
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">pid</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Completed process %d
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">pid</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">now</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">process</span>(<span style="color:#a6e22e">i</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;All processes completed&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">end</span>.<span style="color:#a6e22e">Sub</span>(<span style="color:#a6e22e">now</span>))
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>scripts/go-routines on ÓÇ† main <span style="color:#f92672">[</span>?<span style="color:#f92672">]</span> via üêπ v1.20 
</span></span><span style="display:flex;"><span>$ go run wg.go 
</span></span><span style="display:flex;"><span>Started process <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>Started process <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>Started process <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Started process <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>Started process <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>Started process <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>Started process <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>Started process <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>Started process <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>Started process <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>Completed process <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span>Completed process <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>Completed process <span style="color:#ae81ff">9</span>
</span></span><span style="display:flex;"><span>Completed process <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>Completed process <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Completed process <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>Completed process <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>Completed process <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>Completed process <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>Completed process <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span>1.000563257s
</span></span><span style="display:flex;"><span>All processes completed
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>scripts/go-routines on ÓÇ† main <span style="color:#f92672">[</span>?<span style="color:#f92672">]</span> via üêπ v1.20 
</span></span><span style="display:flex;"><span>$ </span></span></code></pre></div></div>
<p>In the above example, we have used the same function <code>process</code> but with a slight twist, we have added a process id, just an integer to represent the go routine. We print the start and completion of the function in between the sleep for 1 second. We also have a wait group.</p>
<ul>
<li>A <a href="https://pkg.go.dev/sync#WaitGroup"  target="_blank">WaitGroup</a> is basically a struct type defined in the <a href="https://pkg.go.dev/sync"  target="_blank">sync</a> package.</li>
<li>The variable <code>wg</code> is a new wait group instance that will be used to synchronize and wait for the completion of groups of go routines.</li>
</ul>
<p>We create a for loop with <code>10</code> iterations, so as to spawn 10 <code>process</code> function calls. We first use the <code>wg.Add(1)</code> which says to the wait group to wait for 1 go routine. The immediate next line is a go routine <code>go process()</code> which takes in a <code>pid</code> just to track which go routine is being executed in the loop.</p>
<p>Inside the <code>process</code> function, we simply say the process with the given <code>pid</code> has started as a print statement, sleeps for a second, and then print the end of the process with <code>pid</code>. The end of the function is marked with <code>defer wg.Done()</code>, this is to indicate that the go routine is completed.</p>
<p>The wg(wait group) has a counter that keeps track of the number of go routines it has to synchronize or wait for them to complete. In the <a href="https://pkg.go.dev/sync#WaitGroup.Add"  target="_blank">Add</a> function, the internal counter in the <code>WaitGroup</code> is incremented by the <code>delta</code> the integer parsed as a parameter. And the <a href="https://pkg.go.dev/sync#WaitGroup.Done"  target="_blank">Done</a> function, decrements the internal counter in the <code>WaitGroup</code> which indicates that the go routine is completed.</p>
<p>In the main function, we call the <a href="https://pkg.go.dev/sync#WaitGroup.Wait"  target="_blank">wg.Wait</a> which will block until the counter for the <code>WaitGroup</code> is 0 i.e. all go routines have completed their execution. So, we created 10 go routines which ran concurrently but were synchronized with the help of WaitGroups. The WaitGroup is allowed to block the main function till all the go routines are done executing.</p>

<h2 class="relative group">Go Routine with WaitGroup Use Cases
    <div id="go-routine-with-waitgroup-use-cases" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#go-routine-with-waitgroup-use-cases" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>Go routines can be used for creating asynchronous tasks, and also for creating concurrent tasks. By using wait groups, we can create a way to wait for multiple goroutines to complete. By using go routines and wait groups, we can complete n number of tasks in a time frame of 1 task&rsquo;s completion. However, to create concurrent communication between the other processes, we need <code>channels</code> (which we will explore in the next article).</p>
<p>Here is a simple breakdown of what asynchronous and concurrent tasks might refer to:</p>
<p><strong>Asynchronous</strong> tasks run independently of the main program flow, allowing the main program to continue executing without waiting for the task&rsquo;s completion. For example, not blocking other tasks in the sequential flow of the main function.</p>
<p><strong>Concurrent</strong> tasks run simultaneously and can execute at the same time as other tasks. They make use of multiple threads (goroutines in Go&rsquo;s case) to achieve parallel execution. For example, running multiple tasks parallel will cut the time down for spinning each task after the completion of another task.</p>
<p>Some of the asynchronous tasks that can be done with go routines might include the following:</p>
<ul>
<li>Sending a mail while saving the user to the database.</li>
<li>Fetch and process data from multiple websites(web scraping/crawling).</li>
<li>High-performance message brokers and queuing systems for inter-process communication.</li>
</ul>
<p>One practical way of using go routines with wait groups would be to send mail, we are not going to see the actual implementation of the mail-sending stuff. However, we can try to mimic how the setup might be for sending bulk mail. By creating a wait group and a list of mail addresses to send, a go routine can be created with a function that sends those emails.</p>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sendMail</span>(<span style="color:#a6e22e">address</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Sending mail to&#34;</span>, <span style="color:#a6e22e">address</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Actual mail sending, smtp stuff</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// handle errors</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// client, err := smtp.Dial(&#34;smtp.example.com:587&#34;)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// errr = client.Mail(&#34;sender@example.com&#34;)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// err = client.Rcpt(address)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// wc, err := client.Data()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//_, err = wc.Write([]byte(&#34;This is the email body.&#34;))</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// err = wc.Close()</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// client.Quit()</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">emails</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;recipient1@example.com&#34;</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;recipient2@example.com&#34;</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;xyz@example.com&#34;</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(len(<span style="color:#a6e22e">emails</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">email</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">emails</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">sendMail</span>(<span style="color:#a6e22e">email</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;All emails queued for sending&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Do other stuff</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<p>In the above example, the <code>emails</code> is a list of email ids to send the mail. We have created a wait group that we can initialize with the total number of go routines probably to be executed. The <code>wg.Add</code> method is parsed with the number of emails to be sent hence that equals the go routines to spawn.</p>
<p>So, we can then in the for loop, iterate over each mail and send the emails with the <code>sendMail</code> function as go routine. The <code>wg.Wait</code> function outside the loop, will make sure the main function is halted before all the go routines complete their execution.</p>
<p>There is one more way to call a function as a go routine without changing its signature since we had to pass <code>wg</code> pointer as the WaitGroup reference to it to acknowledge the completion of the go routine. We could wrap these two operations wiz. calling the function and calling the <code>wg.Done</code> method with an anonymous function.</p>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sendMail</span>(<span style="color:#a6e22e">address</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Sending mail to&#34;</span>, <span style="color:#a6e22e">address</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">emails</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;recipient1@example.com&#34;</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;recipient2@example.com&#34;</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#e6db74">&#34;xyz@example.com&#34;</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(len(<span style="color:#a6e22e">emails</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">email</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">emails</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">mail</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">email</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">sendMail</span>(<span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		}(<span style="color:#a6e22e">mail</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;All emails queued for sending&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Do other stuff</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<p>This does the exact same thing, but we don&rsquo;t have to change the signature of the function, This keeps the functional logic of the function in its place and handles the concurrency on the go.</p>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">email</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">emails</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mail</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">email</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sendMail</span>(<span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>    }(<span style="color:#a6e22e">mail</span>)
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<p>If the above bit scares you, don&rsquo;t worry it&rsquo;s too simple.</p>
<ul>
<li>We are iterating over the email slice using a for loop and creating a Go routine for each email address. The loop variable email represents the email address at the current iteration.</li>
<li>However, to avoid the loop variable capture issue (where all Go routines would share the same email variable), we create a new variable mail and assign the value of email to it. This step ensures that each Go routine captures its own copy of the email address.</li>
<li>We immediately create an anonymous function (a closure) using the go keyword. This anonymous function takes the <code>mail</code> variable as a parameter m and is executed concurrently as a Go routine. Inside the Go routine, we call the <code>sendMail</code> function with the email address <code>m</code>.</li>
<li>After the <code>sendMail</code> call has been executed i.e. email has been sent, we call wg.Done() to notify the WaitGroup that the Go routine has completed its work. This allows the WaitGroup to properly synchronize and wait for all Go routines to finish before the program proceeds beyond wg.Wait() in the main function.</li>
</ul>
<p>This is one way to do it if you want to separate the mail-sending logic from the goroutines/concurrency task. However, this should be handled with care as the variables inside the closure might be shared among all the goroutines instead of having individual variable literals.</p>
<p>To ensure that each goroutine operates on its own copy of the email address, we use the approach of creating a new variable mail and passing it as a parameter to the anonymous function. This way, each goroutine captures its unique email address, avoiding any interference or unintended sharing of data between goroutines.</p>

<h2 class="relative group">Mutual Exclusion Locks
    <div id="mutual-exclusion-locks" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#mutual-exclusion-locks" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>In the previous examples, we saw how goroutines and wait groups allow us to run multiple tasks concurrently in Go. However, sometimes these concurrent goroutines need to access shared resources like memory, files, network sockets, etc.</p>
<p>When more than one goroutine tries to access a resource at the same time, it can lead to <strong>race conditions</strong> and unpredictable behavior. To handle this, we need a way to ensure only one goroutine can access the resource at a time.</p>
<p>This is where mutual exclusion locks come in. A <strong>mutual exclusion lock</strong>, or <strong>mutex</strong>, provides a mechanism to lock access to a shared resource. It ensures only one goroutine at a time can acquire the lock, blocking other goroutines until the lock is released.</p>
<p>For example, say we have multiple goroutines trying to append data to the same memory buffer(could be file/database/etc.) concurrently:</p>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WriteToFile</span>(<span style="color:#a6e22e">filename</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">contents</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">buffer</span> <span style="color:#f92672">*</span>[]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">buffer</span> = append(<span style="color:#f92672">*</span><span style="color:#a6e22e">buffer</span>, []byte(<span style="color:#a6e22e">contents</span>)<span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">WriteFile</span>(<span style="color:#a6e22e">filename</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">buffer</span>, <span style="color:#ae81ff">0644</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sharedBuffer</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">WriteToFile</span>(<span style="color:#e6db74">&#34;data/f1.txt&#34;</span>, <span style="color:#e6db74">&#34;Hello &#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sharedBuffer</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">WriteToFile</span>(<span style="color:#e6db74">&#34;data/f1.txt&#34;</span>, <span style="color:#e6db74">&#34;World! &#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sharedBuffer</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">sharedBuffer</span>))
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go run --race no-mutex.go
</span></span><span style="display:flex;"><span><span style="color:#f92672">==================</span>
</span></span><span style="display:flex;"><span>WARNING: DATA RACE
</span></span><span style="display:flex;"><span>Read at 0x00c000012030 by goroutine 8:
</span></span><span style="display:flex;"><span>  main.WriteToFile<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:11 +0xe7
</span></span><span style="display:flex;"><span>  main.main.func2<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:24 +0x64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Previous write at 0x00c000012030 by goroutine 7:
</span></span><span style="display:flex;"><span>  main.WriteToFile<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:11 +0x16a
</span></span><span style="display:flex;"><span>  main.main.func1<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:23 +0x64
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Goroutine <span style="color:#ae81ff">8</span> <span style="color:#f92672">(</span>running<span style="color:#f92672">)</span> created at:
</span></span><span style="display:flex;"><span>  main.main<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:24 +0x1f6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Goroutine <span style="color:#ae81ff">7</span> <span style="color:#f92672">(</span>finished<span style="color:#f92672">)</span> created at:
</span></span><span style="display:flex;"><span>  main.main<span style="color:#f92672">()</span>
</span></span><span style="display:flex;"><span>      /home/meet/code/100-days-of-golang/scripts/go-routines/no-mutex.go:23 +0x14e
</span></span><span style="display:flex;"><span><span style="color:#f92672">==================</span></span></span></code></pre></div></div>
<p>This is because we are trying to access the same memory address at the same time. This is a race condition and can lead to unpredictable behavior. Try removing the <code>--race</code> flag while running, in this little stupid example, it might not be obvious, but in complex and constrained environments, this can get the application in serious trouble.</p>
<p><strong>NOTE</strong>: We are using <code>go run --race no-mutex.go</code> to check if there are any race conditions in the program. This is the <a href="https://go.dev/doc/articles/race_detector"  target="_blank">race detector</a> flag in the run command.</p>
<p>To avoid this race condition, we need to add the mutex locks provided in the <a href="https://pkg.go.dev/sync#Mutex"  target="_blank">sync.Mutex</a> type. There are methods like <a href="" >Lock</a>, <a href="" >Unlock</a>, and <a href="" >TryLock</a> which help in locking access of the resource to a single entity at a given time.</p>
<p>When a goroutine calls <code>Lock()</code> on a mutex, it acquires the lock. If the mutex is already locked by another goroutine, the calling goroutine will be blocked (put to sleep) until the lock becomes available. Once the lock is acquired successfully, the goroutine can proceed with its critical section, which is the part of the code that should not be executed concurrently by multiple goroutines.</p>
<p>When a goroutine calls <code>Unlock()</code> on a mutex, it releases the lock. This allows other waiting goroutines to acquire the lock and execute their critical sections. It&rsquo;s essential to ensure that <code>Unlock()</code> is called after the critical section to release the mutex and avoid deadlocks. The critical section/shared resource should not be accessed after the release of this lock.</p>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WriteToFile</span>(<span style="color:#a6e22e">filename</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">contents</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">buffer</span> <span style="color:#f92672">*</span>[]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>, <span style="color:#a6e22e">mutex</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">contentBytes</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#a6e22e">contents</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mutex</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">buffer</span> = append(<span style="color:#f92672">*</span><span style="color:#a6e22e">buffer</span>, <span style="color:#a6e22e">contentBytes</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">OpenFile</span>(<span style="color:#a6e22e">filename</span>, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">O_APPEND</span>|<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">O_WRONLY</span>, <span style="color:#ae81ff">0644</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Close</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">f</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">contentBytes</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mutex</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mut</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sharedBuffer</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">WriteToFile</span>(<span style="color:#e6db74">&#34;data/f1.txt&#34;</span>, <span style="color:#e6db74">&#34;Hello Gophers!
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sharedBuffer</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">mut</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">WriteToFile</span>(<span style="color:#e6db74">&#34;data/f1.txt&#34;</span>, <span style="color:#e6db74">&#34;Welcome to Goworld!
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">sharedBuffer</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">mut</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">sharedBuffer</span>))
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go run --race mutex.go
</span></span><span style="display:flex;"><span>Welcome to Goworld!
</span></span><span style="display:flex;"><span>Hello Gophers!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ go run --race mutex.go
</span></span><span style="display:flex;"><span>Hello Gophers!
</span></span><span style="display:flex;"><span>Welcome to Goworld!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ go run --race mutex.go
</span></span><span style="display:flex;"><span>Hello Gophers!
</span></span><span style="display:flex;"><span>Welcome to Goworld!
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ go run --race mutex.go
</span></span><span style="display:flex;"><span>Welcome to Goworld!
</span></span><span style="display:flex;"><span>Hello Gophers!</span></span></code></pre></div></div>
<p>The above example is a preventive measure for race conditions with a mutex Lock on the shared resource used in the go routines.</p>
<p>Let&rsquo;s break down the code step by step. First, we initialize a few variables:</p>
<ul>
<li>
<p><code>wg</code> as <code>sync.WaitGroup</code>:<br>
The <code>wg</code> is a waitgroup that will be used for the synchronization of the go-routines by blocking the main function to exit</p>
</li>
<li>
<p><code>mut</code> as <code>sync.Mutex</code>:<br>
The <code>mut</code> is a structure that internally holds a few integer values indicating either a blocked or unblocked state. The <code>sync.Mutex</code> has two private fields wiz. <code>state</code> and <code>sema</code>, the state holds the mutex state either <code>0</code>(unlocked) or <code>1</code> as locked. The <code>sema</code> field is a <code>uint32</code> that is used for blocking and signaling, it acts as a semaphore to manage blocking and unblocking goroutines trying to acquire the mutex.<br>
This will be used to acquire <code>Lock</code> and <code>Unlock</code> on the shared resource while writing the data to the file or appending the data to the resource.</p>
</li>
<li>
<p><code>sharedBuffer</code> as <code>[]byte</code>:<br>
The <code>sharedBuffer</code> is the actually shared resource that will be used to hold the strings for keeping track of the data written to the file. It will be the resource that would require to lock for mutating its value(appending to the slice) among the go routines.</p>
</li>
</ul>
<p>We add <code>2</code> to the <code>wg</code> to indicate to wait for the two go-routines to complete, in the next line we call two go routines as the function <code>WriteToFile</code>. The <code>WriteToFile</code> is a function that takes in quite a few parameters namely, the filename, the content to write, the reference to the sharedBuffer, waitgroup, and the mutex.</p>
<p>Inside the function <code>WriteToFile</code>:</p>
<ul>
<li>We first <code>defer</code> the <code>waitgroups</code> as <code>Done</code> i.e. to call the <code>wg.Done</code> method at the end of the function call.</li>
<li>Typecast the <code>contents</code> from <code>string</code> as the <code>[]byte</code>.</li>
<li>Acquire the <code>mutex.Lock()</code> i.e. to say &ldquo;The below operations should not be done concurrently, one at a time&rdquo;. We then append the <code>contents</code> to the <code>buffer</code> which is a pointer to the <code>sharedBuffer</code> in the main function, so essentially we are trying to mutate the <code>sharedBuffer</code> in this function.</li>
<li>Open the file as <code>O_APPEND</code> and <code>O_WRONLY</code> to indicate that the file should be opened in append/writing mode. (We have observed this type of operation in the <a href="https://www.meetgor.com/golang-file-write/"  target="_blank">Golang: File Write</a> article)</li>
<li>Use the <code>Write</code> method to write the slice of bytes(contents) into the file that we opened. We have a <code>defer</code> for the closing of the file.</li>
</ul>
<p>We obviously check for errors and print them, but it could be a <code>panic</code> or <code>log</code> depending on the type of operation the application is doing.<br>
So that is the all operation we want to do, so we finally open the lock with <code>mutex.Unlock()</code> which will allow the other go routine if any to access the resource and proceed with the operations.</p>

<h3 class="relative group">Read Write Mutual Exclusion Lock
    <div id="read-write-mutual-exclusion-lock" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#read-write-mutual-exclusion-lock" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>The mutual exclusion lock is good if you have a write operation-heavy application. However, if we have read write operations in more or the less in same proportion(read heavy) we don&rsquo;t want to have readers getting blocked when other readers are accessing the resource since it is not a mutation process.</p>
<p>We could allow many readers to read simultaneously. But for the writing operation, we want to block the readers/writers. The writer should be given preference first in case of a lock by other writers. This would prevent a writer from waiting for readers to complete. This is usually referred to as <strong>Read Write Mutual Exclusion</strong>.</p>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">reader</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">count</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>, <span style="color:#a6e22e">mutex</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">mutex</span>.<span style="color:#a6e22e">TryLock</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Reader %d blocked!
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">id</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">mutex</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Reader %d: read count %d
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">id</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">count</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">writer</span>(<span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">increment</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">count</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>, <span style="color:#a6e22e">mutex</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">mutex</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mutex</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">increment</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Writer %d: wrote count %d
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">id</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">count</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mutex</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">readers</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">writers</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">readers</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">readers</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">reader</span>(<span style="color:#a6e22e">i</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">count</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">mutex</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">writers</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">writers</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">writer</span>(<span style="color:#a6e22e">i</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">count</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">mutex</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go run --race no-rwmutex.go 
</span></span><span style="display:flex;"><span>Reader 0: read count <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">3</span> blocked!
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">2</span> blocked!
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">1</span> blocked!
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">4</span> blocked!
</span></span><span style="display:flex;"><span>Writer 0: wrote count <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>Writer 1: wrote count <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>Writer 2: wrote count <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ go run --race no-rwmutex.go 
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">2</span> blocked!
</span></span><span style="display:flex;"><span>Reader 0: read count <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">1</span> blocked!
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">4</span> blocked!
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">3</span> blocked!
</span></span><span style="display:flex;"><span>Writer 2: wrote count <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>Writer 0: wrote count <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>Writer 1: wrote count <span style="color:#ae81ff">4</span></span></span></code></pre></div></div>
<p>The above example has a <code>reader</code> and a <code>writer</code> method, the <code>reader</code> method simply has to read the shared resource <code>count</code>. It acquires a <code>Mutex</code> lock before reading and unlocks it thereafter. Similarly, the <code>writer</code> function is used for incrementing the <code>count</code> shared resource.</p>
<p>The <code>reader</code> method has a <a href="https://pkg.go.dev/sync#Mutex.TryLock"  target="_blank">TryLock</a> method that tries to acquire a mutex lock on the resource, if the resource is already locked, the function will return <code>false</code> and hence we can say that the reading is blocked(just for demonstration). And if the function <code>TryLock</code> returns <code>true</code>, it will acquire the <code>Lock</code>. We further <code>defer</code> the <code>Unlock</code> and access the <code>count</code> variable which is passed as a reference.</p>
<p>The <code>writer</code> method is simply acquiring the <code>Lock</code> and incrementing the <code>counter</code> and thereafter <code>Unlock</code> is called with <code>defer</code>.</p>
<p>In the above code:</p>
<ul>
<li>The <code>reader</code> and the <code>writer</code> both might be waiting for the lock to be released, however, for readers to wait for reading doesn&rsquo;t make sense.</li>
<li>Because if you would want to just read a particular memory address, there shouldn&rsquo;t be any locks for one reader to wait for other readers to finish.</li>
<li>However, for writing, there has to be a lock. The mutex lock will lock the resource irrespective of the <code>reader</code> or <code>writer</code>.</li>
</ul>
<p>This might not be as visible here, but it might be the reason, that all the <code>readers</code> are blocked from reading due to another reader&rsquo;s or writer&rsquo;s lock.</p>
<p>The <code>sync</code> package has the <a href="https://pkg.go.dev/sync#RWMutex"  target="_blank">RWMutex</a> that does this exact same thing. It is almost similar to the <code>Mutex</code> however, it would allow concurrent reading operation and prefer writing operation before readers to prevent writer starvation.</p>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;sync&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;time&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">reader</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">count</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>, <span style="color:#a6e22e">mutex</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">mutex</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">mutex</span>.<span style="color:#a6e22e">TryRLock</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Reader %d blocked!
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">id</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Reader %d: read count %d
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">id</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">count</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">writer</span>(<span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">increment</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">count</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">wg</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>, <span style="color:#a6e22e">mutex</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">mutex</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mutex</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">increment</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Writer %d: wrote count %d
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">id</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">count</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">mutex</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">readers</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">writers</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">readers</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">readers</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">reader</span>(<span style="color:#a6e22e">i</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">count</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">mutex</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">writers</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">writers</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#a6e22e">writer</span>(<span style="color:#a6e22e">i</span>, <span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">count</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">wg</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">mutex</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div></div>
<div class="highlight-wrapper"><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ go run --race rwmutex.go 
</span></span><span style="display:flex;"><span>Reader 0: read count <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Reader 3: read count <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Reader 1: read count <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Reader 2: read count <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Reader 4: read count <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Writer 1: wrote count <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>Writer 0: wrote count <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>Writer 2: wrote count <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>Writer 3: wrote count <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>Writer 4: wrote count <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ go run --race rwmutex.go 
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">1</span> blocked!
</span></span><span style="display:flex;"><span>Reader 0: read count <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">2</span> blocked!
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">3</span> blocked!
</span></span><span style="display:flex;"><span>Reader <span style="color:#ae81ff">4</span> blocked!
</span></span><span style="display:flex;"><span>Writer 4: wrote count <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>Writer 0: wrote count <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>Writer 1: wrote count <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>Writer 3: wrote count <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>Writer 2: wrote count <span style="color:#ae81ff">6</span></span></span></code></pre></div></div>
<p>In the modified example, all the logic remains the same, just the <code>sync.Mutex</code> is replaced with <code>sync.RWMutex</code>. Also for trying to acquire the lock in the <code>reader</code> method <a href="https://pkg.go.dev/sync#RWMutex.RLock"  target="_blank">TryRLock</a> is used instead of <a href="https://pkg.go.dev/sync#RWMutex.TryRLock"  target="_blank">TryLock</a> which will check if the existing lock acquired is of a reader or writer, if it is a reader, it will return <code>true</code>, else <code>false</code>. Also the <code>Unlock</code> is replaced with the <code>RUnlock</code> method for releasing the read lock. In the <code>writer</code> method, everything remains the same so the writer has to acquire the lock irrespective of whether the current lock is from the reader/writer, so it is a normal <code>Lock</code> and <code>Unlock</code>.</p>
<p>In the above example, we can see all the read operations sometimes are executed instead of getting blocked. This is due to the <code>RWMutex</code> Lock and Unlock on the read operation/function.</p>
<ul>
<li>When one reader is reading, it can&rsquo;t block other readers.</li>
<li>However with simple <code>Mutex</code>, the reader is even blocked when another reader is reading.</li>
<li>For the write operation, it will be blocked as usual, so if a writer is performing a write operation and a reader/readers come in, they will be blocked, also if in the meantime, while the resource is locked, another writer comes in, the writer will be given preference instead of waiting for all readers to complete. This prevents writer starvation.</li>
</ul>
<p>You can see, that the readers are still blocked the majority of the time, however, they are blocked due to the writer locking the resource and not any other reader.</p>
<p>There is a bit more suitable <a href="https://github.com/Mr-Destructive/100-days-of-golang/blob/main/scripts/go-routines/file-rw.go"  target="_blank">example</a> related to <code>file</code> reading and writing with <code>RWMutex</code>, make sure to check that out to get a more clear understanding of an actual case of using the <code>RWMutex</code>.</p>

<h3 class="relative group">Channels
    <div id="channels" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#channels" aria-label="Anchor">#</a>
    </span>
    
</h3>
<p>This is a big part and I would like to delve into this topic in a separate post. There are some patterns like <code>fan-in</code>, <code>fan-out</code>, <code>worker-pool</code>, <code>pub-sub</code>, etc. which are really common in web applications and backend systems. These patterns we shall explore in the next article.</p>
<p>Channels are a way to provide a safe and idiomatic way for Goroutines to exchange data and coordinate their execution without resorting to low-level mechanisms like shared memory or explicit locking.</p>
<p>That&rsquo;s it from the 30th part of the series, all the source code for the examples are linked in the GitHub on the <a href="https://github.com/Mr-Destructive/100-days-of-golang/tree/main/scripts/go-routines"  target="_blank">100 days of Golang</a> repository.</p>

<h3 class="relative group">References:
    <div id="references" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#references" aria-label="Anchor">#</a>
    </span>
    
</h3>
<ul>
<li><a href="https://blog.nindalf.com/posts/how-goroutines-work/"  target="_blank">How Goroutines Work</a></li>
<li><a href="https://blog.logrocket.com/concurrency-patterns-golang-waitgroups-goroutines/"  target="_blank">Concurrency patterns in Golang: WaitGroups and Goroutines</a></li>
<li><a href="https://riteeksrivastava.medium.com/a-complete-journey-with-goroutines-8472630c7f5c"  target="_blank">A complete journey with Goroutines</a></li>
</ul>

<h2 class="relative group">Conclusion
    <div id="conclusion" class="anchor"></div>
    
    <span
        class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100 select-none">
        <a class="text-primary-300 dark:text-neutral-700 !no-underline" href="#conclusion" aria-label="Anchor">#</a>
    </span>
    
</h2>
<p>From this part of the series, the fundamentals of golang&rsquo;s concurrency model were understood specifically spawning go-routines, synchronously executing go-routines with the help of a wait group, mutex locks, and how to secure concurrent access to a shared resource. In the next part of the series, these concepts will be used in asynchronous communication using channels.</p>
<p>Hopefully, you have got the basics of concurrency in golang cleared from this post. If you have any queries, suggestions, or feedback, please feel free to comment below or contact me on the social handles. Thank you for reading. Happy Coding :)</p>

          
          
          
        </div>
        
        
        

        

      </div>

      
      
        
        
          
          
        
        
        
        <script
          type="text/javascript"
          src="/js/page.min.54b6f4371722649edbe871e431d8670d670878c22be8f36e229fe53cc9b786fe25a834def5e6de621f7a3e37b72bc8cd73839aa5ed907ed6cbd45cd3e1b0fa20.js"
          integrity="sha512-VLb0NxciZJ7b6HHkMdhnDWcIeMIr6PNuIp/lPMm3hv4lqDTe9ebeYh96Pje3K8jNc4Oape2QftbL1FzT4bD6IA=="
          data-oid="views_posts/2023-07-29-GO-30-GoRoutines.md"
          data-oid-likes="likes_posts/2023-07-29-GO-30-GoRoutines.md"></script>
      
    </section>

    
    <footer class="pt-8 max-w-prose print:hidden">
      
  
    
    
    
    <div class="pt-8">
      <hr class="border-dotted border-neutral-300 dark:border-neutral-600">
      <div class="flex justify-between pt-3">
        <span class="flex flex-col">
          
            <a
              class="flex text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
              href="/posts/golang-generics/">
              <span class="leading-6">
                <span class="inline-block rtl:rotate-180">&larr;</span>&ensp;Golang: Generics
              </span>
            </a>
            
              <span class="ms-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400">
                <time datetime="2023-07-23T13:30:00&#43;00:00">July 23, 2023</time>
              </span>
            
          
        </span>
        <span class="flex flex-col items-end">
          
            <a
              class="flex text-right text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
              href="/posts/mindsdb-grafbase/">
              <span class="leading-6">
                MindsDB GraphQL API (Grafbase)&ensp;<span class="inline-block rtl:rotate-180">&rarr;</span>
              </span>
            </a>
            
              <span class="me-6 mt-1 text-xs text-neutral-500 dark:text-neutral-400">
                <time datetime="2023-08-13T20:00:00&#43;00:00">August 13, 2023</time>
              </span>
            
          
        </span>
      </div>
    </div>
  


      
    </footer>
  </article>

        


  






<div
  id="scroll-to-top"
  class="fixed bottom-6 end-6 z-50 transform translate-y-4 opacity-0 duration-200">
  <a
    href="#the-top"
    class="pointer-events-auto flex h-12 w-12 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400"
    aria-label="Scroll to top"
    title="Scroll to top">
    &uarr;
  </a>
</div>

      </main><footer id="site-footer" class="py-10 print:hidden">
  
  
    
  
  <div class="flex items-center justify-between">
    
    
      <p class="text-sm text-neutral-500 dark:text-neutral-400">
          &copy;
          2026
          Meet Gor
      </p>
    

    
    
      <p class="text-xs text-neutral-500 dark:text-neutral-400">
        
        
        Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
          href="https://gohugo.io/" target="_blank" rel="noopener noreferrer">Hugo</a> &amp; <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500"
          href="https://blowfish.page/" target="_blank" rel="noopener noreferrer">Blowfish</a>
      </p>
    
  </div>
  
    <script>
      mediumZoom(document.querySelectorAll("img:not(.nozoom)"), {
        margin: 24,
        background: "rgba(0,0,0,0.5)",
        scrollOffset: 0,
      });
    </script>
  
  
  
  <script
    type="text/javascript"
    src="/js/process.min.ee03488f19c93c2efb199e2e3014ea5f3cb2ce7d45154adb3399a158cac27ca52831db249ede5bb602700ef87eb02434139de0858af1818ab0fb4182472204a4.js"
    integrity="sha512-7gNIjxnJPC77GZ4uMBTqXzyyzn1FFUrbM5mhWMrCfKUoMdsknt5btgJwDvh&#43;sCQ0E53ghYrxgYqw&#43;0GCRyIEpA=="></script>
  
  
</footer>
<div
  id="search-wrapper"
  class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh] z-500"
  data-url="/">
  <div
    id="search-modal"
    class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800">
    <header class="relative z-10 flex items-center justify-between flex-none px-2">
      <form class="flex items-center flex-auto min-w-0">
        <div class="flex items-center justify-center w-8 h-8 text-neutral-400">
          <span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span>
        </div>
        <input
          type="search"
          id="search-query"
          class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent"
          placeholder="Search"
          tabindex="0">
      </form>
      <button
        id="close-search-button"
        class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400"
        title="Close (Esc)">
        <span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentColor" d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>
</span>
      </button>
    </header>
    <section class="flex-auto px-2 overflow-auto">
      <ul id="search-results">
        
      </ul>
    </section>
  </div>
</div>

    </div>
  </body>
  
</html>
